/*****************************************************
 * project: Qt Json Class Generator
 * author: hezouzao
 * usage :
 * Step I.
 * supported types ( by now ):
 * QBitArray                    -> bit array
 * bool                         -> bool
 * QByteArray                   -> byte array
 * QChar/char                   -> char
 * QDate                        -> date
 * QDateTime                    -> date time
 * double                       -> double
 * QEasingCurve                 -> easing curve
 * float                        -> float
 * int/qint32                   -> int
 * QLine                        -> line
 * QLineF                       -> line float
 * QList<T>                     -> T, true (true means it's an array type)
 * QLocale                      -> locale
 * qlonglong/qint64/long long   -> long long
 * QModelIndex                  -> model index
 * QPersistentModelIndex        -> persistent model index
 * QPoint                       -> point
 * QPointF                      -> point float
 * qreal                        -> real
 * QRect                        -> rect
 * QRectF                       -> rect float
 * QRegExp                      -> regexp (QT_VERSION < Qt5.0)
 * QRegularExpression           -> regular expression (QT_VERSION >= Qt5.0)
 * QSize                        -> size
 * QSizeF                       -> size float
 * QString                      -> string
 * QTime                        -> time
 * uint                         -> unsigned int
 * qulonglong                   -> unsigned long long
 * QUrl                         -> url
 * QUuid                        -> unsigned unique id
 * input your script file like : family.txt
 * ###################### file: family.txt ######################
 * chinese family               # -> class ChineseFamily {};
 * member, string, true         # -> QList<QString> m_member;
 * single parent, bool, false   # -> bool m_single_parent;
 * address, string, false       # -> QString m_address;
 * ###################### file: family.txt ######################
 * and we will get hpp and cpp files: family.hpp and family.cpp,
 * you can find these two generated files from our project /demo
 * folder, and it's so easy to write a script like this, isn't?
 * and make it advancer, look at this file: person.txt
 * ###################### file: person.txt ######################
 * require family.txt           # -> include header files
 * person                       # -> class Person {};
 * name, string, false          # -> QString m_name;
 * age, int, false              # -> int m_age;
 * children, string, true       # -> QList<QString> m_children;
 * cards, int, true             # -> QList<int> m_cards;
 * family, chinese family, false# -> ChineseFamily m_family;
 * ###################### file: person.txt ######################
 * and we will get: person.hpp and person.cpp files which are 
 * available in /demo folder.
 * Pay attention to "require" line, it will check if the classes
 * are generated, if not, it will generate the classes required 
 * by header declaration, and then move on to compile this file.
 * and the types to describe the fields of class should either
 * be found in Qt Supported Types listed above, or the customized
 * classes generated by this system, and it cannot be the one that
 * is in the definition process, which means you cannot add a
 * field of type [person] within class definition of [person], it
 * will cause infinitive loop error.
 * [*] Plus, no spaces and single or double quotes are allowed in path
 * of the script file and the "require" header sentences.
 * [*] Plus, no more than 1023 chars are allowed to stand within a line!
 * [*] Plus, only one class can be defined in a class description file!
 * Step II.
 * when you got these generated classes, you can add your own
 * properties and methods, and they won't affect the JSON system,
 * but keep in mind that, you are always free to use these classes
 * to serialize and deserialize themselves with these API:
 * auto object = new [Generated Class]([parent]);
 * QByteArray json = object.serialize();
 * object.deserialze([instance of QByteArray]);
 */

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <filesystem>
#include <list>
#include <map>

#define _CHAR_COUNT_IN_LINE_ 1024
#define _KEYWORD_REQUIRE_ "require"


// a global resource
std::map<std::string, std::string> _supported_types = {
    std::pair<std::string, std::string>("bit array",                "QBitArray"),
    std::pair<std::string, std::string>("bool",                     "bool"),
    std::pair<std::string, std::string>("byte array",               "QByteArray"),
    std::pair<std::string, std::string>("char",                     "QChar"),
    std::pair<std::string, std::string>("date",                     "QDate"),
    std::pair<std::string, std::string>("date time",                "QDateTime"),
    std::pair<std::string, std::string>("double",                   "double"),
    std::pair<std::string, std::string>("easing curve",             "QEasingCurve"),
    std::pair<std::string, std::string>("float",                    "float"),
    std::pair<std::string, std::string>("int",                      "qint32"),
    std::pair<std::string, std::string>("line",                     "QLine"),
    std::pair<std::string, std::string>("line float",               "QLineF"),
    std::pair<std::string, std::string>("locale",                   "QLocale"),
    std::pair<std::string, std::string>("long long",                "qint64"),
    std::pair<std::string, std::string>("model index",              "QModelIndex"),
    std::pair<std::string, std::string>("persistent model index",   "QPersistentModelIndex"),
    std::pair<std::string, std::string>("point",                    "QPoint"),
    std::pair<std::string, std::string>("point float",              "QPointF"),
    std::pair<std::string, std::string>("real",                     "qreal"),
    std::pair<std::string, std::string>("rect",                     "QRect"),
    std::pair<std::string, std::string>("rect float",               "QRectF"),
    std::pair<std::string, std::string>("regexp",                   "QRegExp"),
    std::pair<std::string, std::string>("regular expression",       "QRegularExpression"),
    std::pair<std::string, std::string>("size",                     "QSize"),
    std::pair<std::string, std::string>("size float",               "QSizeF"),
    std::pair<std::string, std::string>("string",                   "QString"),
    std::pair<std::string, std::string>("time",                     "QTime"),
    std::pair<std::string, std::string>("unsigned int",             "uint"),
    std::pair<std::string, std::string>("unsigned long long",       "qulonglong"),
    std::pair<std::string, std::string>("url",                      "QUrl"),
    std::pair<std::string, std::string>("unsigned unique id",       "QUuid")
};

std::map<std::string, std::string> _convertor_map = {
    std::pair<std::string, std::string>("QBitArray",                "toBitArray"),
    std::pair<std::string, std::string>("bool",                     "toBool"),
    std::pair<std::string, std::string>("QByteArray",               "toByteArray"),
    std::pair<std::string, std::string>("QChar",                    "toChar"),
    std::pair<std::string, std::string>("QDate",                    "toDate"),
    std::pair<std::string, std::string>("QDateTime",                "toDateTime"),
    std::pair<std::string, std::string>("double",                   "toDouble"),
    std::pair<std::string, std::string>("QEasingCurve",             "toEasyCurve"),
    std::pair<std::string, std::string>("float",                    "toFloat"),
    std::pair<std::string, std::string>("qint32",                   "toInt"),
    std::pair<std::string, std::string>("QLine",                    "toLine"),
    std::pair<std::string, std::string>("QLineF",                   "toLineF"),
    std::pair<std::string, std::string>("QLocale",                  "toLocale"),
    std::pair<std::string, std::string>("qint64",                   "toLongLong"),
    std::pair<std::string, std::string>("QModelIndex",              "toModeIndex"),
    std::pair<std::string, std::string>("QPersistentModelIndex",    "toPersistentModelIndex"),
    std::pair<std::string, std::string>("QPoint",                   "toPoint"),
    std::pair<std::string, std::string>("QPointF",                  "toPointF"),
    std::pair<std::string, std::string>("qreal",                    "toReal"),
    std::pair<std::string, std::string>("QRect",                    "toRect"),
    std::pair<std::string, std::string>("QRectF",                   "toRectF"),
    std::pair<std::string, std::string>("QRegExp",                  "toRegExp"),
    std::pair<std::string, std::string>("QRegularExpression",       "toRegularExpression"),
    std::pair<std::string, std::string>("QSize",                    "toSize"),
    std::pair<std::string, std::string>("QSizeF",                   "toSizeF"),
    std::pair<std::string, std::string>("QString",                  "toString"),
    std::pair<std::string, std::string>("QTime",                    "toTime"),
    std::pair<std::string, std::string>("uint",                     "toUInt"),
    std::pair<std::string, std::string>("qulonglong",               "toULongLong"),
    std::pair<std::string, std::string>("QUrl",                     "toUrl"),
    std::pair<std::string, std::string>("QUuid",                    "toUuid")
};

std::list<std::string> classes;

bool compile(const char * script, std::string& generated_class);
std::string trim(const std::string & str);
bool is_name_valide(bool is_head, const std::string & str);
std::list<std::string> split(const std::string & str, char delimiter);
bool make_class_name(std::string & name, std::list<std::string> & words);
std::string make_file_head_macro(const std::string & str);
bool do_class_exists(const std::list<std::string> & classes, const std::string & class_name);
bool make_field_name(std::string& name, const std::string& field_name);

int main(int argc, const char **argv)
{
    // to read the files from script
    if(argc<2)
        std::cout<<"[USAGE] ./QtJsonClassGenerator [your class script file]"<<std::endl;
    
    std::string generated_class;
    
    for(int i=1; i<argc; i++)
    {
        compile(argv[i], generated_class);
    }
}

// the core compile function
bool compile(const char * script, std::string& generated_class)
{
    // get the working directory
    std::tr2::sys::path workdir(script);
    if(workdir.has_parent_path())
        workdir = workdir.parent_path();
    else
        workdir = std::tr2::sys::path(".");
    std::fstream fs;
    fs.open(script, std::ios::in);
    if(!fs.is_open())
    {
        std::cout<<"[ERROR] failed to open file : "<<script<<std::endl;
        return false;
    }
    // begin the compilation
    std::fstream hppfile;
    std::fstream cppfile;
    std::string class_name;
    std::list<std::string> required_classes;
    std::list<std::string> field_names;
    std::list<std::string> field_types;
    std::list<bool> field_is_list;
    std::list<bool> type_is_builtin;
    
    char line[_CHAR_COUNT_IN_LINE_];
    while(fs.getline(line, _CHAR_COUNT_IN_LINE_, '\n'))
    {
        line[_CHAR_COUNT_IN_LINE_-1] = 0;
        std::string str(line);
        str = trim(str);
        if(!str.length())
            continue;
        int idx = str.find('#');
        if(idx>=0)
            str = str.substr(0, idx);
        str = trim(str);
        if(!str.length())
            continue;
        //std::cout<<str<<std::endl;
        
        // compile it
        std::list<std::string> words = split(str, ',');
        if(words.size()==1)
        {
            std::string word = trim(words.front());
            words = split(word, ' ');
            // check if it is a class definition or require sentence
            if(words.front()==std::string(_KEYWORD_REQUIRE_))
            {
                // it is a require header
                words.pop_front();
                while(words.size())
                {
                    word = words.front();
                    words.pop_front();
                    word = trim(word);
                    if(std::tr2::sys::path(word).is_relative())
                        word = workdir.string().append("/").append(word);
                    std::string required_class;
                    if(!compile(word.c_str(), required_class))
                        return false;
                    required_classes.push_back(required_class);
                }
            }
            else
            {
                // this is a class name
                if(!make_class_name(class_name, words))
                {
                    std::cout<<"[ERROR] bad class name!"<<std::endl;
                    return false;
                }
                if(do_class_exists(classes, class_name))
                {
                    std::cout<<"[WARN] class ["<<class_name<<"] already generated!"<<std::endl;
                    return true;
                }
                else
                {
                    // register this class
                    classes.push_back(class_name);
                }
                generated_class = class_name;
            }
        }
        else
        {
            // this is a field declaration
            bool _is_type_builtin = false;
            if(words.size()!=3)
            {
                std::cout<<"[ERROR] bad format for field declaration!"<<std::endl;
                return false;
            }
            std::string _name;
            if(!make_field_name(_name, trim(words.front())))
            {
                std::cout<<"[ERROR] bad format for field name!"<<std::endl;
                return false;
            }
            words.pop_front();
            std::string _type = trim(words.front());
            // check if it is a built-in type
            std::map<std::string, std::string>::const_iterator t_itr = _supported_types.find(_type);
            if(t_itr!=_supported_types.end())
            {
                _is_type_builtin = true;
                _type = t_itr->second;
                //std::cout<<"Built-in type: "<<_type<<std::endl;
            }
            else
            {
                // check if this is a registered class
                _is_type_builtin = false;
                std::list<std::string> t_list = split(_type, ' ');
                if(!make_class_name(_type, t_list))
                {
                    std::cout<<"[ERROR] bad type name: "<< _type <<std::endl;
                    return false;
                }
                if(!do_class_exists(classes, _type))
                {
                    std::cout<<"[ERROR] unsupported and non-registered type: "<<_type<<std::endl;
                    return false;
                }
            }
            words.pop_front();
            std::string t_list = trim(words.front());
            bool _list;
            words.pop_front();
            if(t_list==std::string("true"))
                _list = true;
            else if(t_list==std::string("false"))
                _list = false;
            else
            {
                std::cout<<"[ERROR] bad bool value for describing if a field is a list type: "<<_list<<std::endl;
                return false;
            }
            // add to field list
            field_names.push_back(_name);
            field_types.push_back(_type);
            field_is_list.push_back(_list);
            type_is_builtin.push_back(_is_type_builtin);
            
            std::cout<<"field name: "<<_name<<std::endl;
            std::cout<<"field type: "<<_type<<std::endl;
            std::cout<<"field list: "<<_list<<std::endl;
        }
    }
    
    // do the real job to generate files of classes
    std::cout<<"[OK] begin generate class [ "<<class_name<<" ]"<<std::endl;
    // create class related files : hpp and cpp files
    std::string hppname = class_name;
    std::string cppname = class_name;
    hppname.append(".hpp");
    cppname.append(".cpp");
    hppfile.open(hppname, std::ios::out);
    cppfile.open(cppname, std::ios::out);
    if(!hppfile.is_open()||!cppfile.is_open())
    {
        std::cout<<"[ERROR] failed to create and open files!"<<std::endl;
        hppfile.close();
        cppfile.close();
        return false;
    }
    // hpp header
    hppfile<<"#ifndef "<<make_file_head_macro(class_name)<<std::endl;
    hppfile<<"#define "<<make_file_head_macro(class_name)<<std::endl;
    hppfile<<std::endl;
    hppfile<<"#include <QObject>"<<std::endl;
    hppfile<<"#include <QString>"<<std::endl;
    hppfile<<"#include <QList>"<<std::endl;
    hppfile<<"#include <QVariant>"<<std::endl;
    hppfile<<"#include <QByteArray>"<<std::endl;
    hppfile<<"#include <QVariantList>"<<std::endl;
    hppfile<<"#include <QVariantMap>"<<std::endl;
    // add external headers for field type requirement
    std::list<std::string>::const_iterator itype = field_types.begin();
    std::list<std::string>::const_iterator iname;
    std::list<bool>::const_iterator ilist;
    std::list<bool>::const_iterator ibuiltin = type_is_builtin.begin();
    for(; itype!=field_types.end(); itype++)
        if((*itype)[0]=='Q'&&(*ibuiltin))
            hppfile<<"#include <"<<*itype<<">"<<std::endl;
    hppfile<<std::endl;
    // cpp header
    cppfile<<"#include \""<<hppname<<"\""<<std::endl;
    cppfile<<"#include <QJson/Parser>"<<std::endl;
    cppfile<<"#include <QJson/Serializer>"<<std::endl;
    cppfile<<"#include <QJson/QObjectHelper>"<<std::endl;
    cppfile<<std::endl;
    cppfile<<class_name<<"::"<<class_name<<"(QObject* parent) : QObject(parent){}"<<std::endl;
    cppfile<<class_name<<"::~"<<class_name<<"(){}"<<std::endl;
    cppfile<<std::endl;
    // add generated classes
    std::list<std::string>::const_iterator itr = required_classes.begin();
    for(; itr!=required_classes.end(); itr++)
        hppfile<<"#include \""<<*itr<<".hpp\""<<std::endl;
    hppfile<<std::endl;
    hppfile<<"class "<<class_name<<" : public QObject"<<std::endl;
    hppfile<<"{"<<std::endl;
    hppfile<<"\tQ_OBJECT"<<std::endl;
    itype = field_types.begin();
    iname = field_names.begin();
    ilist = field_is_list.begin();
    ibuiltin = type_is_builtin.begin();
    
    // add constructors to cpp file
    cppfile<<class_name<<"::"<<class_name<<"(const "<<class_name<<"& _"<<class_name<<")"<<std::endl;
    cppfile<<"{"<<std::endl;
    for(; iname!=field_names.end(); iname++)
        cppfile<<"\tSet"<<*iname<<"(_"<<class_name<<".Get"<<*iname<<"());"<<std::endl;
    cppfile<<"}"<<std::endl;
    cppfile<<std::endl;
    cppfile<<class_name<<"& "<<class_name<<"::operator=(const "<<class_name<<"& _"<<class_name<<")"<<std::endl;
    cppfile<<"{"<<std::endl;
    for(iname=field_names.begin(); iname!=field_names.end(); iname++)
        cppfile<<"\tSet"<<*iname<<"(_"<<class_name<<".Get"<<*iname<<"());"<<std::endl;
    cppfile<<"\treturn *this;"<<std::endl;
    cppfile<<"}"<<std::endl;
    cppfile<<std::endl;
    
    for(iname=field_names.begin(); itype!=field_types.end(); ++itype, ++iname, ++ilist, ++ibuiltin)
    {
        if(*ilist)
        {
            hppfile<<"\tQ_PROPERTY(QVariantList "<<*iname<<" READ Get"<<*iname<<" WRITE Set"<<*iname<<")"<<std::endl;
        }
        else
        {
            if(*ibuiltin)
                hppfile<<"\tQ_PROPERTY("<<*itype<<" "<<*iname<<" READ Get"<<*iname<<" WRITE Set"<<*iname<<")"<<std::endl;
            else
                hppfile<<"\tQ_PROPERTY(QVariantMap "<<*iname<<" READ Get"<<*iname<<" WRITE Set"<<*iname<<")"<<std::endl;
        }
    }
    hppfile<<"public:"<<std::endl;
    hppfile<<"\t"<<class_name<<"(QObject* parent=0);"<<std::endl;
    hppfile<<"\t~"<<class_name<<"();"<<std::endl;
    hppfile<<"\t"<<class_name<<"(const "<<class_name<<"& _"<<class_name<<");"<<std::endl;
    hppfile<<"\t"<<class_name<<"& operator=(const "<<class_name<<"& _"<<class_name<<");"<<std::endl;
    hppfile<<std::endl;
    
    itype = field_types.begin();
    iname = field_names.begin();
    ilist = field_is_list.begin();
    ibuiltin = type_is_builtin.begin();
    
    for(; itype!=field_types.end(); ++itype, ++iname, ++ilist, ++ibuiltin)
    {
        if(*ilist)
        {
            hppfile<<"\tQVariantList Get"<<*iname<<"() const;"<<std::endl;
            hppfile<<"\tvoid Set"<<*iname<<"(const QVariantList& _"<<*iname<<");"<<std::endl;
            hppfile<<std::endl;
            // implementation
            if(*ibuiltin)
            {
                // getter
                cppfile<<"QVariantList "<<class_name<<"::Get"<<*iname<<"() const"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\tQVariantList _"<<*iname<<";"<<std::endl;
                cppfile<<"\tQList<"<<*itype<<">::const_iterator itr=m"<<*iname<<".begin();"<<std::endl;
                cppfile<<"\tfor(; itr!=m"<<*iname<<".end(); itr++)"<<std::endl;
                cppfile<<"\t\t_"<<*iname<<".push_back(*itr);"<<std::endl;
                cppfile<<"\treturn _"<<*iname<<";"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
                //setter
                cppfile<<"void "<<class_name<<"::Set"<<*iname<<"(const QVariantList& _"<<*iname<<")"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\tQVariantList::const_iterator itr=_"<<*iname<<".begin();"<<std::endl;
                cppfile<<"\tm"<<*iname<<".clear();"<<std::endl;
                cppfile<<"\tfor(; itr!=_"<<*iname<<".end(); itr++)"<<std::endl;
                std::map<std::string, std::string>::const_iterator iconv = _convertor_map.find(*itype);
                if(iconv==_convertor_map.end())
                {
                    std::cout<<"[ERROR] no available convertor for type: "<<*itype<<std::endl;
                    return false;
                }
                cppfile<<"\t\tm"<<*iname<<".push_back((*itr)."<<iconv->second<<"());"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
            }
            else
            {
                // getter
                cppfile<<"QVariantList "<<class_name<<"::Get"<<*iname<<"() const"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\tQVariantList _"<<*iname<<";"<<std::endl;
                cppfile<<"\tQList<"<<*itype<<">::const_iterator itr=m"<<*iname<<".begin();"<<std::endl;
                cppfile<<"\tfor(; itr!=m"<<*iname<<".end(); itr++)"<<std::endl;
                cppfile<<"\t{"<<std::endl;
                cppfile<<"\t\t"<<*itype<<" _ref = *itr;"<<std::endl;
                cppfile<<"\t\t_"<<*iname<<".push_back(QJson::QObjectHelper::qobject2qvariant(&_ref));"<<std::endl;
                cppfile<<"\t}"<<std::endl;
                cppfile<<"\treturn _"<<*iname<<";"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
                // setter
                cppfile<<"void "<<class_name<<"::Set"<<*iname<<"(const QVariantList& _"<<*iname<<")"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\tm"<<*iname<<".clear();"<<std::endl;
                cppfile<<"\tQVariantList::const_iterator itr="<<"_"<<*iname<<".begin();"<<std::endl;
                cppfile<<"\tfor(; itr!=_"<<*iname<<".end(); itr++)"<<std::endl;
                cppfile<<"\t{"<<std::endl;
                cppfile<<"\t\t"<<*itype<<" _ref;"<<std::endl;
                cppfile<<"\t\tQJson::QObjectHelper::qvariant2qobject((*itr).toMap(), &_ref);"<<std::endl;
                cppfile<<"\t\tm"<<*iname<<".push_back(_ref);"<<std::endl;
                cppfile<<"\t}"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
            }
        }
        else
        {
            if(*ibuiltin)
            {
                // declaration
                hppfile<<"\t"<<*itype<<" Get"<<*iname<<"() const;"<<std::endl;
                hppfile<<"\tvoid Set"<<*iname<<"(const "<<*itype<<"& _"<<*iname<<");"<<std::endl;
                hppfile<<std::endl;
                // implementation
                // getter
                cppfile<<*itype<<" "<<class_name<<"::Get"<<*iname<<"() const"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\treturn m"<<*iname<<";"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
                // setter
                cppfile<<"void "<<class_name<<"::Set"<<*iname<<"(const "<<*itype<<"& _"<<*iname<<")"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\tthis->m"<<*iname<<" = _"<<*iname<<";"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
            }
            else
            {
                // declaration
                hppfile<<"\tQVariantMap Get"<<*iname<<"() const;"<<std::endl;
                hppfile<<"\tvoid Set"<<*iname<<"(const QVariantMap& _"<<*iname<<");"<<std::endl;
                hppfile<<std::endl;
                // implementation
                // getter
                cppfile<<"QVariantMap "<<class_name<<"::Get"<<*iname<<"() const"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\treturn QJson::QObjectHelper::qobject2qvariant(&m"<<*iname<<");"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
                // setter
                cppfile<<"void "<<class_name<<"::Set"<<*iname<<"(const QVariantMap& _"<<*iname<<")"<<std::endl;
                cppfile<<"{"<<std::endl;
                cppfile<<"\tQJson::QObjectHelper::qvariant2qobject(_"<<*iname<<", &m"<<*iname<<");"<<std::endl;
                cppfile<<"}"<<std::endl;
                cppfile<<std::endl;
            }
        }
    }
    
    // add modifiers to class
    hppfile<<"\t// modifiers"<<std::endl;
    for(iname=field_names.begin(),itype=field_types.begin(),ilist=field_is_list.begin();
        iname!=field_names.end();
        iname++, itype++, ilist++)
    {
        if(*ilist)
        {
            // declaration
            hppfile<<"\tQList<"<<*itype<<">& Get"<<*iname<<"Ref();"<<std::endl;
            // implementation
            cppfile<<"QList<"<<*itype<<">& "<<class_name<<"::Get"<<*iname<<"Ref()"<<std::endl;
            cppfile<<"{"<<std::endl;
            cppfile<<"\treturn m"<<*iname<<";"<<std::endl;
            cppfile<<"}"<<std::endl;
            cppfile<<std::endl;
        }
        else
        {
            // declaration
            hppfile<<"\t"<<*itype<<"& Get"<<*iname<<"Ref();"<<std::endl;
            // implementation
            cppfile<<*itype<<"& "<<class_name<<"::Get"<<*iname<<"Ref()"<<std::endl;
            cppfile<<"{"<<std::endl;
            cppfile<<"\treturn m"<<*iname<<";"<<std::endl;
            cppfile<<"}"<<std::endl;
            cppfile<<std::endl;
        }
    }
    
    // add serializer and deserializer
    // declaration
    hppfile<<"\t//serializer and deserializer"<<std::endl;
    hppfile<<"\tQByteArray serialize();"<<std::endl;
    hppfile<<"\tvoid deserialize(const QByteArray& data);"<<std::endl;
    hppfile<<"\tbool ok() const;"<<std::endl;
    // implementation
    // serializer
    cppfile<<"QByteArray "<<class_name<<"::serialize()"<<std::endl;
    cppfile<<"{"<<std::endl;
    cppfile<<"\tQVariantMap map = QJson::QObjectHelper::qobject2qvariant(this);"<<std::endl;
    cppfile<<"\tQJson::Serializer serializer;"<<std::endl;
    cppfile<<"\treturn serializer.serialize(map, &mOK);"<<std::endl;
    cppfile<<"}"<<std::endl;
    cppfile<<std::endl;
    // deserializer
    cppfile<<"void "<<class_name<<"::deserialize(const QByteArray& data)"<<std::endl;
    cppfile<<"{"<<std::endl;
    cppfile<<"\tQJson::Parser parser;"<<std::endl;
    cppfile<<"\tQVariant var = parser.parse(data, &mOK);"<<std::endl;
    cppfile<<"\tQJson::QObjectHelper::qvariant2qobject(var.toMap(), this);"<<std::endl;
    cppfile<<"}"<<std::endl;
    cppfile<<std::endl;
    // ok 
    cppfile<<"bool "<<class_name<<"::ok() const"<<std::endl;
    cppfile<<"{"<<std::endl;
    cppfile<<"\treturn mOK;"<<std::endl;
    cppfile<<"}"<<std::endl;
    cppfile<<std::endl;
    
    // the private members of class
    hppfile<<"private:"<<std::endl;
    for(iname=field_names.begin(),itype=field_types.begin(),ilist=field_is_list.begin();
        iname!=field_names.end();
        iname++, itype++, ilist++)
    {
        if(*ilist)
            hppfile<<"\tQList<"<<*itype<<"> m"<<*iname<<";"<<std::endl;
        else
            hppfile<<"\t"<<*itype<<" m"<<*iname<<";"<<std::endl;
    }
    hppfile<<"\tbool mOK;"<<std::endl;
    hppfile<<"};"<<std::endl;
    hppfile<<std::endl;
    hppfile<<"#endif // "<<make_file_head_macro(class_name)<<std::endl;
    hppfile<<std::endl;
    
    return true;
}

std::string trim(const std::string & str)
{
    int n = str.length();
    int left_pos = 0;
    // trim spaces off in front
    for(int i=0; i<n; ++i)
    {
        if(str[i]==' ')
            ++ left_pos;
        else
            break;
    }
    // trim spaces off at back
    int right_pos = n-1;
    for(int i=n-1; i>=0; --i)
    {
        if(str[i]==' ')
            -- right_pos;
        else
            break;
    }
    return str.substr(left_pos, right_pos-left_pos+1);
}

bool is_name_valide(bool is_head, const std::string & str)
{
    int n = str.length();
    if(!n)
        return false;
    int pos = 0;
    if(is_head)
    {
        // the first alphabet
        char ch = str[pos++];
        if(ch!='_' && (ch<'A'||ch>'Z') && (ch<'a'||ch>'z'))
            return false;
    }
    for(int i=pos; i<n; ++i)
    {
        char ch = str[i];
        if(ch!='_' && (ch<'A'||ch>'Z') && (ch<'a'||ch>'z') && (ch<'0'||ch>'9'))
            return false;
    }
    
    return true;
}

// please ensure to use the list with pop_front() to get right order
std::list<std::string> split(const std::string  & str, char delimiter)
{
    std::list<std::string> words;
    int n = str.length();
    int last_id = -1;
    int word_len = 0;
    for(int i=0; i<n; i++)
    {
        if(str[i]==delimiter)
        {
            if(word_len>0)
                words.push_back(str.substr(last_id+1, word_len));
            last_id = i;
            word_len = 0;
        }
        else
            word_len ++;
    }
    if(last_id<n-1)
        words.push_back(str.substr(last_id+1, word_len));
    return words;
}

// words will be emptied
bool make_class_name(std::string & name, std::list<std::string> & words)
{
    // for the first word in list
    name.clear();
    std::string word = words.front();
    words.pop_front();
    if(!is_name_valide(true, word))
        return false;
    // make the first letter capsulated
    if(word[0]>='a'&&word[0]<='z')
        word[0] = word[0] - ('a'-'A');
    name.append(word);
    while(words.size())
    {
        word = words.front();
        words.pop_front();
        if(!is_name_valide(false, word))
            return false;
        if(word[0]>='a'||word[0]<='z')
            word[0] = word[0] - ('a'-'A');
        name.append(word);
    }
    
    return true;
}

std::string make_file_head_macro(const std::string & str)
{
    std::string macro_name = str;
    int n = str.size();
    for(int i=0; i<n; i++)
        if(str[i]>='a'&&str[i]<='z')
            macro_name[i] = str[i] - ('a'-'A');
    macro_name.append("_H");
    return macro_name;
}

bool do_class_exists(const std::list<std::string> & classes, const std::string & class_name)
{
    std::list<std::string>::const_iterator i = classes.begin();
    for(; i!=classes.end(); ++i)
    {
        if((*i)==class_name)
            return true;
    }
    
    return false;
}

bool make_field_name(std::string& name, const std::string& field_name)
{
    name.clear();
    std::list<std::string> words = split(field_name, ' ');
    std::string word = words.front();
    words.pop_front();
    if(!is_name_valide(true, word))
        return false;
    // make the first letter capsulated
    if(word[0]>='a'&&word[0]<='z')
        word[0] = word[0] - ('a'-'A');
    name.append(word);
    while(words.size())
    {
        word = words.front();
        words.pop_front();
        if(!is_name_valide(false, word))
            return false;
        if(word[0]>='a'||word[0]<='z')
            word[0] = word[0] - ('a'-'A');
        name.append(word);
    }
    return true;
}
